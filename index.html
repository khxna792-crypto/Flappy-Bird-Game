<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="https://techcrunch.com/wp-content/uploads/2014/02/flappy.jpeg">
    <title>Flappy Bird Game</title>
    
</head>
<body>
    <canvas id="board"></canvas>
</body>


<style>
    body {
    font-family: 'Courier New', Courier, monospace;
    text-align: center;
    background-color: black;
}

#board {
    background-image: url("./Images/flappybirdbg.png");
    cursor: default;
}
</style>




<script>
    

let boardWidth = 360; 
let boardHeight = 572; 
let inputLocked = false; 
let score = 0;
let bestScore = 0;

// Background images
let dayBg = new Image();
dayBg.src = "./Images/flappybirdbg.png";
let nightBg = new Image();
nightBg.src = "./Images/background-night.png";
let currentBg = dayBg;

// Digit images for score
let digitImgs = [];
for(let i = 0; i <= 9; i++){
    let img = new Image();
    img.src = `./Images/${i}.png`;
    digitImgs.push(img);
}

// Sounds
let flapSound = new Audio("./Audio/Wing.ogg");
let pointSound = new Audio("./Audio/point.wav");
let hitSound = new Audio("./Audio/hit.ogg");


// Coins
let coinImg = new Image();
coinImg.src = "./Images/coin.png";
let coinArray = [];
let coinWidth = 30;
let coinHeight = 30;

// Pipes
let pipeArray = [];
let pipeWidth = 50;
let pipeGap = 200;
let velocityX = -2;

// Bird
let birdSkins = [
    "./Images/bluebird-mid.png",
    "./Images/redbird-downflap.png"
];
let birdSkinIndex = 0;
let birdImg = new Image();
birdImg.src = birdSkins[birdSkinIndex];
let bird = { x:50, y:boardHeight/2, width:40, height:30, velocityY:0 };

// Play button
let playButtonImg = new Image();
playButtonImg.src = "./Images/flappyBirdPlayButton.png";
let playButton = { x: boardWidth/2 - 115.5/2, y: boardHeight/2 - 64/2 + 80, width:115, height:64 };

// Logo
let flappyBirdTextImg = new Image();
flappyBirdTextImg.src = "./Images/flappyBirdLogo.png";
let logo = { x: boardWidth/2 - 300/2, y: boardHeight/4, width:300, height:100 };

// Game Over
let gameOverImg = new Image();
gameOverImg.src = "./Images/flappy-gameover.png";

let gravity = 0.4;       // gentle downward pull
let flapStrength = -7;  
let birdY = boardHeight / 2; 
let pipeIntervalId;

function flap() {
    bird.velocityY = flapStrength;
    flapSound.play();
}

document.addEventListener("keydown", e => { if(e.code==="Space") flap(); });
document.addEventListener("click", flap);


// Game states
let GAME_STATE = { MENU:"menu", PLAYING:"playing", GAME_OVER:"gameOver" };
let currentState = GAME_STATE.MENU;

// Canvas
let board, context;
window.onload = function() {
    board = document.getElementById("board"); 
    board.height = boardHeight; 
    board.width = boardWidth;
    context = board.getContext("2d"); 

    topPipeImg = new Image();
    topPipeImg.src = "./Images/toppipe.png"; 

    bottomPipeImg = new Image(); 
    bottomPipeImg.src = "./Images/bottompipe.png"; 

    requestAnimationFrame(update); 
}

// Event listeners
document.addEventListener("keydown", handleKeyDown);
document.addEventListener("click", handleMouseClick);

// Cooldown
let lastActionTime = 0;
const cooldown = 250; // ms

function update() {
    requestAnimationFrame(update);
    context.clearRect(0,0, board.width, board.height);

    if(currentState === GAME_STATE.MENU) renderMenu();
    else if(currentState === GAME_STATE.PLAYING) renderGame();
    else if(currentState === GAME_STATE.GAME_OVER) renderGameOver();
}

function renderMenu() {
    if(currentBg.complete) context.drawImage(currentBg, 0, 0, boardWidth, boardHeight); 
    if(playButtonImg.complete) context.drawImage(playButtonImg, playButton.x, playButton.y, playButton.width, playButton.height); 
    if(flappyBirdTextImg.complete){
        let scaledWidth = logo.width; 
        let scaledHeight = (flappyBirdTextImg.height / flappyBirdTextImg.width) * scaledWidth; 
        context.drawImage(flappyBirdTextImg, logo.x, logo.y, scaledWidth, scaledHeight); 
    }
    context.drawImage(birdImg, bird.x, bird.y, bird.width, bird.height);
}

function renderGame() {
    // Update background
    updateBackground();
    if(currentBg.complete) context.drawImage(currentBg, 0, 0, boardWidth, boardHeight);

    // Bird movement
    bird.velocityY += gravity;
    bird.y = Math.max(bird.y + bird.velocityY, 0);
    drawBird();

    if(bird.y > board.height){
        hitSound.play();
        currentState = GAME_STATE.GAME_OVER;
        changeBirdSkin();
    }

    // Pipes
    for(let i = 0; i < pipeArray.length; i++){
        let pipe = pipeArray[i];
        pipe.x += velocityX;
        context.drawImage(pipe.img, pipe.x, pipe.y, pipe.width, pipe.height);

        if(!pipe.passed && bird.x > pipe.x + pipe.width){
            score += 0.5;
            pipe.passed = true;
            if(score % 1 === 0) pointSound.play();
        }

        if(detectCollision(bird, pipe)){
            hitSound.play();
            currentState = GAME_STATE.GAME_OVER;
            changeBirdSkin();
        }
    }

    renderCoins();
    drawScore();

    while(pipeArray.length > 0 && pipeArray[0].x < -pipeWidth) pipeArray.shift();
}

// Background toggle every 12 points
function updateBackground(){
    currentBg = (Math.floor(score / 12) % 2 === 0) ? dayBg : nightBg;
}

// Change bird skin for next game
function changeBirdSkin(){
    birdSkinIndex = (birdSkinIndex + 1) % birdSkins.length;
    birdImg.src = birdSkins[birdSkinIndex];
}

function renderCoins() {
    for(let i = 0; i < coinArray.length; i++){
        let coin = coinArray[i];
        coin.x += velocityX;

        if(!coin.collected){
            context.drawImage(coinImg, coin.x, coin.y, coin.width, coin.height);

            if(bird.x < coin.x + coin.width &&
               bird.x + bird.width > coin.x &&
               bird.y < coin.y + coin.height &&
               bird.y + bird.height > coin.y){
                   coin.collected = true;
                   score += 1;
                   pointSound.play();
            }
        }
    }

    coinArray = coinArray.filter(c => c.x + c.width > 0 && !c.collected);
}

function drawScore() {
    let scoreStr = Math.floor(score).toString();
    let startX = 10;
    let y = 20;
    let digitWidth = 30;
    let digitHeight = 45;

    for(let i = 0; i < scoreStr.length; i++){
        let num = parseInt(scoreStr[i]);
        let img = digitImgs[num];
        if(img.complete){
            context.drawImage(img, startX + i * (digitWidth + 2), y, digitWidth, digitHeight);
        }
    }
}

function renderGameOver() {
    if(currentBg.complete) context.drawImage(currentBg,0,0,boardWidth,boardHeight);
    if(gameOverImg.complete){
        let imgWidth = 400, imgHeight = 80;
        let x = (boardWidth - imgWidth)/2;
        let y = boardHeight/3;

        context.drawImage(gameOverImg, x, y, imgWidth, imgHeight);

        context.fillStyle = "white";
        context.font = "45px sans-serif";
        context.textAlign = "center";
        context.fillText(`Score: ${Math.floor(score)}`, boardWidth/2, y + imgHeight + 50);

        saveBestScore();
        context.fillText(`Best: ${bestScore}`, boardWidth/2, y + imgHeight + 110);

        if(playButtonImg.complete) context.drawImage(playButtonImg, playButton.x, playButton.y + 100, playButton.width, playButton.height);

        inputLocked = true;
        setTimeout(() => { inputLocked = false; }, 300); // cooldown
    }
}

function handleKeyDown(e) {
    if(inputLocked || Date.now()-lastActionTime<250) return;
    lastActionTime = Date.now();

    if(e.code === "Space"){
        if(currentState === GAME_STATE.MENU) startGame();
        else if(currentState === GAME_STATE.GAME_OVER){
            resetGame();
            currentState = GAME_STATE.MENU;
        }
        else if(currentState === GAME_STATE.PLAYING){
            bird.velocityY = -6;
            flapSound.play();
        }
    }
}

function handleMouseClick(e) {
    if(inputLocked || Date.now()-lastActionTime<250) return;
    lastActionTime = Date.now();

    let rect = board.getBoundingClientRect();
    let mouseX = e.clientX - rect.left;
    let mouseY = e.clientY - rect.top;

    if(currentState === GAME_STATE.MENU){
        if(mouseX >= playButton.x && mouseX <= playButton.x + playButton.width &&
           mouseY >= playButton.y && mouseY <= playButton.y + playButton.height){
            startGame();
        }
    }
    else if(currentState === GAME_STATE.GAME_OVER){
        if(mouseX >= playButton.x && mouseX <= playButton.x + playButton.width &&
           mouseY >= playButton.y + 100 && mouseY <= playButton.y + 100 + playButton.height){
            resetGame();
            currentState = GAME_STATE.MENU;
        }
    }
    else if(currentState === GAME_STATE.PLAYING){
        bird.velocityY = -6;
        flapSound.play();
    }
}

function startGame() {
    currentState = GAME_STATE.PLAYING; 
    bird.y = birdY; 
    bird.velocityY = 0; 
    pipeArray = []; 
    coinArray = [];
    score = 0;

    if(pipeIntervalId) clearInterval(pipeIntervalId);
    pipeIntervalId = setInterval(placePipes, 1500); 
}

function resetGame() {
    bird.y = birdY;
    bird.velocityY = 0;
    pipeArray = []; 
    coinArray = [];
    score = 0;
}

function detectCollision(a, b) {
    return a.x < b.x + b.width &&
           a.x + a.width > b.x && 
           a.y < b.y + b.height &&
           a.y + a.height > b.y;
}

function drawBird() {
    let angle = 0;
    if(bird.velocityY < 0) angle = -0.3;
    else if(bird.velocityY > 2) angle = 0.4;

    context.save();
    context.translate(bird.x + bird.width / 2, bird.y + bird.height / 2);
    context.rotate(angle);
    context.drawImage(birdImg, -bird.width / 2, -bird.height / 2, bird.width, bird.height);
    context.restore();
}

function placePipes() {
    createPipes();
}

function createPipes() {
    let maxTopPipeHeight = boardHeight - pipeGap - 50;
    let topPipeHeight = Math.floor(Math.random() * maxTopPipeHeight); 
    let bottomPipeHeight = boardHeight - topPipeHeight - pipeGap;

    let topPipe = { x: boardWidth, y:0, width: pipeWidth, height: topPipeHeight, img: topPipeImg, passed:false };
    let bottomPipe = { x: boardWidth, y:topPipeHeight + pipeGap, width: pipeWidth, height: bottomPipeHeight, img: bottomPipeImg, passed:false };
    pipeArray.push(topPipe, bottomPipe);

    // Spawn a coin in the gap
    let coinY = topPipeHeight + 50 + Math.random() * (pipeGap - 100);
    let coin = { x: boardWidth + pipeWidth/2, y: coinY, width: coinWidth, height: coinHeight, collected:false };
    coinArray.push(coin);
}

function saveBestScore() {
    if(score > bestScore) bestScore = Math.floor(score);
}


function renderCoins() {
    for (let i = 0; i < coinArray.length; i++) {
        let coin = coinArray[i];
        coin.x += velocityX;

        if (coin.collected) continue;

        // Initialize rotation
        if (!coin.spinAngle) coin.spinAngle = 0;
        coin.spinAngle += 0.15; // speed of spin

        let scaleX = Math.cos(coin.spinAngle); // simulate rotation on vertical axis
        scaleX = Math.abs(scaleX); // flip negative side to positive

        context.save();
        context.translate(coin.x + coin.width/2, coin.y + coin.height/2);
        context.scale(scaleX, 1); // scale width to simulate spin
        context.drawImage(coinImg, -coin.width/2, -coin.height/2, coin.width, coin.height);
        context.restore();

        // Collision with bird
        if (bird.x < coin.x + coin.width &&
            bird.x + bird.width > coin.x &&
            bird.y < coin.y + coin.height &&
            bird.y + bird.height > coin.y) {
                coin.collected = true;
                score += 1;
                pointSound.play();
        }
    }

    coinArray = coinArray.filter(c => c.x + c.width > 0 && !c.collected);
}


function renderGame() {
    updateBackground();
    if(currentBg.complete) context.drawImage(currentBg,0,0,boardWidth,boardHeight);

    bird.velocityY += gravity;
    bird.y = Math.max(bird.y + bird.velocityY, 0);
    drawBird();

    if(bird.y > board.height){
        hitSound.play();
        currentState = GAME_STATE.GAME_OVER;
        birdSkinIndex = (birdSkinIndex + 1) % birdSkins.length;
        birdImg.src = birdSkins[birdSkinIndex];
    }

    for(let i = 0; i < pipeArray.length; i++){
        let pipe = pipeArray[i];

        // Pipe shake effect
        if(!pipe.shake) pipe.shake = 0; // initialize shake
        let shakeOffset = Math.sin(pipe.shake) * 5; // amplitude of shake
        if(pipe.shake > 0) pipe.shake += 0.3; // continue shaking
        if(pipe.shake > Math.PI) pipe.shake = 0; // stop after full shake

        pipe.x += velocityX;
        context.drawImage(pipe.img, pipe.x, pipe.y + shakeOffset, pipe.width, pipe.height);

        // Check if bird passes pipe
        if(!pipe.passed && bird.x > pipe.x + pipe.width){
            score += 0;
            pipe.passed = true;
            pipe.shake = 0.8; // trigger shake
            if(score % 1 === 0) pointSound.play();
        }

        if(detectCollision(bird, pipe)){
            hitSound.play();
            currentState = GAME_STATE.GAME_OVER;
            birdSkinIndex = (birdSkinIndex + 1) % birdSkins.length;
            birdImg.src = birdSkins[birdSkinIndex];
        }
    }

    renderCoins();
    drawScore();

    while(pipeArray.length > 0 && pipeArray[0].x < -pipeWidth) pipeArray.shift();
}


function renderGame() {
    // --- Smooth day/night transition ---
    let cycleLength = 20; // points per full transition
    let t = (score % cycleLength) / cycleLength; // 0 → 1

    // Draw day background
    if(dayBg.complete) context.drawImage(dayBg, 0, 0, boardWidth, boardHeight);

    // Draw night on top with alpha t
    if(nightBg.complete){
        context.globalAlpha = t; 
        context.drawImage(nightBg, 0, 0, boardWidth, boardHeight);
        context.globalAlpha = 1; // reset alpha so other objects are not affected
    }

    // --- Bird physics ---
    bird.velocityY += gravity;
    bird.y = Math.max(bird.y + bird.velocityY, 0);
    drawBird();

    if(bird.y > board.height){
        hitSound.play();
        currentState = GAME_STATE.GAME_OVER;
        birdSkinIndex = (birdSkinIndex + 1) % birdSkins.length;
        birdImg.src = birdSkins[birdSkinIndex];
    }

    // --- Pipes ---
    for(let i = 0; i < pipeArray.length; i++){
        let pipe = pipeArray[i];

        // Optional shake: small vertical shift if bird is close
        let shake = (Math.abs(bird.x - pipe.x) < 50) ? Math.sin(Date.now()/100) * 3 : 0;
        pipe.x += velocityX;
        context.drawImage(pipe.img, pipe.x, pipe.y + shake, pipe.width, pipe.height);

        if(!pipe.passed && bird.x > pipe.x + pipe.width){
            score += 0.5;
            pipe.passed = true;
            if(score % 1 === 0) pointSound.play();
        }

        if(detectCollision(bird, pipe)){
            hitSound.play();
            currentState = GAME_STATE.GAME_OVER;
            birdSkinIndex = (birdSkinIndex + 1) % birdSkins.length;
            birdImg.src = birdSkins[birdSkinIndex];
        }
    }

    // --- Coins ---
    renderCoins();

    // --- Score ---
    drawScore();

    // --- Remove offscreen pipes ---
    while(pipeArray.length > 0 && pipeArray[0].x < -pipeWidth) pipeArray.shift();
}


let pipeCount = 0; // count total pipe pairs created

function createPipes() {
    let maxTopPipeHeight = boardHeight - pipeGap - 50;
    let topPipeHeight = Math.floor(Math.random() * maxTopPipeHeight);
    let bottomPipeHeight = boardHeight - topPipeHeight - pipeGap;

    let topPipe = { x: boardWidth, y:0, width: pipeWidth, height: topPipeHeight, img: topPipeImg, passed:false };
    let bottomPipe = { x: boardWidth, y:topPipeHeight + pipeGap, width: pipeWidth, height: bottomPipeHeight, img: bottomPipeImg, passed:false };
    pipeArray.push(topPipe, bottomPipe);

    pipeCount++; // increase after each pipe pair

    // Spawn a coin every 3 pipe pairs
    if(pipeCount % 3 === 0){
        let coinY = topPipeHeight + 50 + Math.random() * (pipeGap - 100);
        let coin = { x: boardWidth + pipeWidth/2, y: coinY, width: coinWidth, height: coinHeight, collected:false };
        coinArray.push(coin);
    }
}



</script>



</html>